Newspeak3
'Root'
class BigBrotherTrust usingPlatform: platform = (
|
	private List = platform collections List.
    public JSObject = platform js global at: 'Object'.
    private Date = platform js global at: 'Date'.
    private Window = platform js global.
    private Color = platform graphics Color.
    private Gradient = platform hopscotch Gradient.
	private Presenter = platform hopscotch core Presenter.
    private Subject = platform hopscotch core Subject.

	private indexedDB = IndexedDB usingPlatform: platform.
    private IDBObject = indexedDB IDBObject.
    private IDBSubject = platform hopscotch core Subject mixinApply: indexedDB IDBSubject.

    public version = 1.
	public transactions = List new.
|
) (
public class BankTransaction amount: a onDate: d <Integer> = IDBObject (
	|
    amt = a.
    txDate = d.
    |
) (
public txSubject = (
	^BankTransactionSubject onModel: self
)
public asJSObjectx = (| jso = JSObject new. |
	^jso
    	at: 'uuid' put: uuid;
        at: 'amt' put: amt;
        at: 'txDate' put: txDate;
        yourself.
)
public amount = (
			^amt
		)
public transactionDate = (
			^(Date new: txDate) toDateString
		)
) : (
)
class BankTransactionPresenter onSubject: s =  Presenter onSubject: s (
		) (
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankTransactionPresenter
		)
isKindOfBankTransactionPresenter = (
			^true
		)
public definition ^ <Fragment> = (
			^row: {  label: subject transactionDate. blank: 100 . txLabel. txAmount. }
		)
txLabel = ( | txt = subject amount < 0 ifTrue: [ 'Withdrawal:' ] ifFalse: [ 'Deposit:' ]. |
	^column: { label: txt. }
)
txAmount = (
	^column: { label: subject amount }
)
) : (
)
public class BankTransactionSubject onModel: t <BankTransaction> = Subject onModel: t (
		) (
public createPresenter = (
			^BankTransactionPresenter onSubject: self
		)
public transactionDate = (
			^model transactionDate
		)
public amount = (
			^model amount
		)
isKindOfBankTransactionSubject = (
	^true
)
isMyKind: s = (
	^s isKindOfBankTransactionSubject
)
) : (
)
public class BankAccountSubject onModel: b <BigBrotherTrust> = IDBSubject onModel: b (
) (
withdrawals = (
		^txSubjets select: [ :t | t amount < 0 ]
	)
public createPresenter = (
		^BankAccountPresenter onSubject: self
	)
deposits = (
		^model transactions select: [ :t | t amount > 0 ]
	)
public balance = (
		^model balance
	)
public loadTx = (| tx nocors |
	nocors: (js global at: 'Object') new.
    nocors at: 'mode' put: 'no-cors'.
	tx:: (js global fetch: 'http://localhost:8077/transactions' with: nocors)
    		then: [ :r | r json then: [ :data | data ] ].
    ^tx
)
public deposit: amt = (
	transact: amt.
)
onUpgradeNeeded: event = (
    | o = JSObject new. |
    super onUpgradeNeeded: event.
	o  at: 'keyPath' put: 'uuid'.
   db createObjectStore: 'BankTransaction' with: o.
)
onSuccess: event = (
	| o r tx store req |
	super onSuccess: event.
    (* db getAll. *)
    tx:: db transaction: 'BankTransaction' for: 'readonly'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    store:: tx objectStore: 'BankTransaction'.
    req: store getAll.
    req addEventListener: 'success' handler: [ :e | onGetAllSuccess: e. nil ].
)
public transactionSubjects = (
	'transactionSubjects called' out.
	^transactions collect: [ :t | BankTransactionSubject onModel: t ]
)
transact: amt = (| b s d |
		d:: Date now.
		b:: BankTransaction amount: amt onDate: d.
        add: b.
		model transact: b.
)
public withdraw: amt = (
	balance < amt ifTrue: [ ^Window alert: 'Insufficient funds available' ].
	transact: (amt * -1).
)
onGetAllSuccess: event <Alien> = (
	| r = (event at: #target) at: #result. |
    1 to: (r at: #length) do: [ :i | | b a d o |
    	o:: r at: (i - 1).
    	a:: o at: 'amt'.
        d:: (o at: 'txDate').
        b:: BankTransaction amount: a onDate: d.
        transactions add: b.
     ].
     presenter refresh.
    'onGetAllSuccess completed' out.
)
) : (
)
class BankAccountPresenter onSubject: s <BankAccountSubject> = Presenter onSubject: s (|
	stFlag = false.
|) (
isKindOfBankAccountPresenter = (
			^true
		)
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankAccountPresenter
		)
transactionList = (
			^column:  transactionPresenters.
		)
computeDigits: ds = (
| s ::= 0. |
	ds do: [:d | s:: (10 * s) + (d - 48)].
	^s
)
newDepositInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject deposit: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
newWithdrawalInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject withdraw: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
minorHeadingColor = (
	^Gradient from: Color gray to: Color white.
)
loadTx = (
	^subject loadTx
)
transactionsHeader = ( | l = label: 'Transactions'. |
	^row: { l }.
)
minorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.})
	color: minorHeadingColor.
)
majorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.}) color: majorHeadingColor.
)
logo = (| b = label: 'Big Brother Trust'. |
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 200%; text-align: center'.
	^row: { b }
)
header = ( | l = label: 'Your Money'. |
	l visual at: 'style' put: 'font-size: 200%'.
		^row: {  l. }
		)
logoBlock: body = (
	^(padded: body with: { 100. 75. 100. 75. }) color: logoColor.
)
currentBalance ^<Fragment> = (| l = label: 'Balance: $'. b = label: subject balance. |
	l visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
			^row: { l. blank: 20. b }
		)
logoColor = (
	^Color white
)
majorHeadingColor = (
	^Color gray.
)
transactionPresenters = (
	'transactionPresenters called' out.
	^subject transactionSubjects collect: [ :s | s presenter ]
)
public refresh = (
	updateGUI: [ ].
)
public definition ^<Fragment> = (
	^column: {
    	logoBlock: logo.
		majorHeadingBlock: header.
		minorHeadingBlock: currentBalance.
		transactionsHeader.
		transactionList.
		row: { label: 'Deposit:' }.
        row: { newDepositInput. }.
		row: { label: 'Withdrawal:' }.
		row: { newWithdrawalInput. }.
    }
)
) : (
)
public class IndexedDB usingPlatform: platform = (
	|
    (* Imports *)
    public List = platform collections List.
    public Map = platform collections Map.
    private ObjectMirror = platform mirrors ObjectMirror.
    private ClassMirror = platform mirrors ClassMirror.
	private JSObject = platform js global at: 'Object'.
    private crypto = platform js global at: 'crypto'.

    (* The browser's IndexedDB API object *)
    private indexedDB <Alien> = platform js global at: 'indexedDB'.
	|
) (
public class IDBStore forClass: c <IDBObject class> = (
	|
    storeClass <Class> = c.
    keyPath <String> = c keyPath.
    store <Alien>
    |
    createStore
) (
public save: o = (
	^IDBStoreRequest for: o on: self
)
get: aKey = (

)
createStore = (| o = JSObject new at: #keyPath put: keyPath; yourself. |
	'Creating objectStore' out.
	indexedDB createObjectStore: storeClass mixin name with: o.
)
) : (
)
public class IDBObject = (
	|
	uuid
	|
) (
public asJSObject = (
	|
    m = ObjectMirror reflecting: self.
    cm = m getClass.
    o = JSObject new.
    |
	cm slots do: [ :slot | | n v |
    	n: slot name.
        v:: m getSlot: n.
        o at: n put: v reflectee
    ].
	^o
)
) : (
)
public class IDBSubject = (
(*
	This class is to be used as a mixin whose many event handlers can be overriden by your application subject.
	Override onUpgradeNeeded to create the objectStores needed to store your model objects.
    Overrided onSuccess to load data?
    Currently, stores use the class name of the objects to be stored using IDBSubject's add: put: and delete: methods. Custom behavior would require overriding these.
*)
 |
 (* The connection to the application's database *)
 db <Alien>
 |
) (
public onBlocked: e = (
	'Blocked triggered' out.
)
modelClasses = (| m = (ObjectMirror reflecting: model) getClass mixin. |
	^m nestedClasses select: [ :c | c definingMixin superclass = IDBObject ]
)
public onTxComplete: event <Alien> = (
	'Transaction complete triggered' out.
)
public onTxError: e <Alien> = (
	'Transaction error triggered' out.
)
public onUpgradeNeeded: event <Alien> = (
    'upgradeneeded triggered' out.
    db::  (event at: #target) at: #result.
)
public onSuccess: event <Alien> = (
	'Open DB succeeded' out.
    db:: (event at: #target) at: #result.
)
public openDB = (
	|
    cm = (ObjectMirror reflecting: model) getClass.
	request	= indexedDB open: cm mixin name version: model version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e | onSuccess: e. nil ].
    request addEventListener: 'error' with: [ :e | (e at: #error) out. nil ].
	'IDBSubject openDB called' out.
)
public put: o <IDBObject> = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].
    store:: tx objectStore: s.
    store put: o asJSObject.
)
public delete: o = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].
    store:: tx objectStore: s.
    store delete: o uuid.
)
onAddSuccess: event <Alien> = (
	'Add succeeded' out.
)
get: aUUID = (
)
getAll = (
)
public openDB: version <Integer> = (
	|
    cm = (ObjectMirror reflecting: model) getClass.
	request	= indexedDB open: cm mixin name version: version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e | onSuccess: e. nil ].
    request addEventListener: 'error' with: [ :e | (e at: #error) out. nil ].
	'IDBSubject openDB called' out.
)
public add: o = (
	|
    m = ObjectMirror reflecting: o.
	s = m getClass mixin name.
    tx
    store
    req
    |
    (* Create the UUID key for the model *)
    m setSlot: 'uuid' to: crypto randomUUID.

    (* Create the IDBTransaction *)
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].

    (* Get the IDBObjectStore from the transaction *)
    store:: tx objectStore: s.

    (* Store the model object *)
    req:: store add: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onAddSuccess: e. nil ]
)
) : (
)
) : (
)
public transact: b <BankTransaction> = (
	^transactions add: b
)
public balance = (
		^transactions inject: 0 into: [ :s :t | s + t amount ].
	)
) : (
)
