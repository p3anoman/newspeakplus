Newspeak3
'Root'
class BigBrotherTrust usingPlatform: platform indexedDB: idb = (
|
	private List = platform collections List.
    private Color = platform graphics Color.
    private Gradient = platform hopscotch Gradient.
	private Presenter = platform hopscotch core Presenter.
    private Subject = platform hopscotch core Subject.

	public JSObject = platform js global at: 'Object'.
    private Date = platform js global at: 'Date'.
    private JSNumber = platform js global at: 'Number'.
    private crypto = platform js global at: 'crypto'.

	private indexedDB = idb.
    private IDBObject = indexedDB IDBObject.
    private IDBSubject = platform hopscotch core Subject mixinApply: indexedDB IDBSubject.

    public version = 1.
	public transactions = List new.
|
) (
public class BankTransaction id: uuid <UUID> 
													amount: a <String>
                                                    onDate: d <Integer> 
                                                    memo: m <String> = IDBObject uuid: uuid (
	|
    public amount = a.
    public txDate = d.
    public memo = m.
    public reconciled = false.
    |
) (
public transactionDate = (
			^(Date new: txDate) toDateString
		)
) : (
public new: array = (
	^self id: (array at: 0) amount: (array at: 1) onDate: (array at: 2) memo: (array at: 3)
)
)
class BankTransactionPresenter onSubject: s =  Presenter onSubject: s (
		) (
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankTransactionPresenter
		)
isKindOfBankTransactionPresenter = (
			^true
		)
dateColumn= (| lbl = label: subject transactionDate. |
	lbl visual at: 'style' put: style.
	^column: { lbl }
)
typeColumn = ( | lbl = label: subject transactionType. |
	lbl visual at: 'style' put: style.
	^column: { lbl. }
)
style = (
	^'font-family: sans-serif; font-size: 110%; color: slateGray'
)
deleteButton = (
	^button: 'Delete' action: [ updateGUI: [ subject delete ] ]
)
transactionBlock: row = (
	^(padded: row with: { 10. 10. 10. 10. }) color: (Color r: 0.99 g: 0.99 b: 0.99 a: 1).
)
editButton = (
	^button: 'Edit' action: [ enterSubject: (BankTransactionEditSubject onModel: subject model parentSubject: subject) ]
)
amountColumn = (| lbl = label: ((JSNumber new: (subject amount / 100)) toFixed: 2). |
	lbl visual at: 'style' put: style, 'text-align: right'.
	^column: { lbl }
)
reconciledColumn = (
	^column: { checkbox: 'Reconciled' value: subject reconciled action: [ :ck | subject toggleReconciled ] }
)
memoColumn = ( | lbl = label: subject memo. |
	lbl visual at: 'style' put: style.
	^column: { lbl }
)
definition ^ <Fragment> = (
	^transactionBlock: transactionRow
)
transactionRow = (
	^row: {  
			dateColumn.
            blank: 50.
            typeColumn.
            blank: 50.
            memoColumn.
            blank: 50.
            amountColumn.
            blank: 100.
            reconciledColumn.
            blank: 100.
            editButton.
            deleteButton.
	}
)
) : (
)
public class BankTransactionSubject onModel: t <BankTransaction> parent: s <IDBSubject> = Subject onModel: t (
	|
    parent = s.
    |
) (
public createPresenter = (
			^BankTransactionPresenter onSubject: self
		)
isKindOfBankTransactionSubject = (
	^true
)
isMyKind: s = (
	^s isKindOfBankTransactionSubject
)
public amount = (
			^model amount
		)
public transactionDate = (
 ^model transactionDate
)
public transactionType = (
	^amount < 0 ifTrue: [ 'Withdrawal:' ] ifFalse: [ 'Deposit:' ]
)
public delete = (
	parent delete: model.
)
public edit = (
	parent edit: model
)
toggleReconciled = (
	model reconciled ifFalse: [ model reconciled: true ]
)
public memo = (
	^model memo
)
public reconciled = (
	^model reconciled
)
) : (
)
public class BankAccountSubject onModel: b <BigBrotherTrust> = IDBSubject onModel: b (
) (
withdrawals = (
		^txSubjets select: [ :t | t amount < 0 ]
	)
public createPresenter = (
		^BankAccountPresenter onSubject: self
	)
deposits = (
		^model transactions select: [ :t | t amount > 0 ]
	)
public balance = (
		^model balance
	)
public deposit: amt = (
	transact: amt.
)
modelClasses = (
	^{ BankTransaction. }
)
public transactionSubjects = (
	^transactions collect: [ :t | BankTransactionSubject onModel: t parent: self ]
)
public delete: o = (
	delete: o 
    	onComplete: [ :e | 
        	transactions remove: o.
            presenter refresh.
            nil ] 
        onError: [ :e | 
        	presenter alert: 'Failed to delete transaction: ', ((e at: #error) at: 'message'). 
            nil ]
)
public edit: transaction = (
	presenter enterSubject: (BankTransactionEditSubject onModel: transaction parentSubject: self)
)
transact: amt = (| b s d |
		d:: Date now.
		b:: BankTransaction id: crypto randomUUID amount: amt onDate: d memo: ''.
        add: b
)
public withdraw: amt = ( | a = Number parseFloat: amt. |
	balance < a ifTrue: [ ^Window alert: 'Insufficient funds available' ].
	transact:: (Number new: (a * -1)) toFixed: 2.
)
public add: b <BankTransaction> = (
        add: b
        	onComplete: [ :e | 
            	'Tx complete' out.
            	model transact: b.
                presenter refresh.
                nil ]
            onError: [ :e | presenter alert: ((e at: 'error') at: 'message'). nil ]
)
onGetAll: event <Alien> = (
	| txs = super onGetAll: event. |
    txs do: [ :tx | transactions add: tx ].
    presenter refresh.
)
) : (
)
class BankAccountPresenter onSubject: s <BankAccountSubject> = Presenter onSubject: s (|
	stFlag = false.
|) (
isKindOfBankAccountPresenter = (
			^true
		)
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankAccountPresenter
		)
transactionList = (
			^column:  transactionPresenters.
		)
newDepositInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject deposit: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
newWithdrawalInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject withdraw: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
minorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.})
	color: minorHeadingColor.
)
majorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.}) color: majorHeadingColor.
)
logo = (| b = label: 'Big Brother Trust'. |
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 200%; text-align: center'.
	^row: { b }
)
header = ( | l = label: 'Your Money'. |
	l visual at: 'style' put: 'font-size: 200%'.
		^row: {  l. }
		)
logoBlock: body = (
	^(padded: body with: { 100. 75. 100. 75. }) color: logoColor.
)
logoColor = (
	^Color white
)
public refresh = (
	updateGUI: [ ].
)
labelDeposit = (| lbl = label: 'Deposit:'. |
	lbl visual at: #style put: labelStyle.
    ^lbl
)
labelWithdrawal = (| lbl =  label: 'Withdrawal:'. |
	lbl visual at: #style put: labelStyle.
    ^lbl
)
labelTransactions = ( | lbl = label: 'Transactions'. |
	lbl visual at: #style put: labelStyle.
	^ lbl
)
minorHeadingColor = (
	^Color r: 0.8 g: 0.8 b: 0.8 a: 1.
)
public definition ^<Fragment> = (
	^column: {
    	logoBlock: logo.
		majorHeadingBlock: header.
		minorHeadingBlock: currentBalance.
        row: {}.
		row: { labelTransactions }.
		transactionList.
		row: { labelDeposit }.
        row: { newDepositInput. }.
		row: { labelWithdrawal }.
		row: { newWithdrawalInput. }.
    }
)
transactionPresenters = (
	^subject transactionSubjects collect: [ :s | s presenter ]
)
majorHeadingColor = (
	^Color r: 0.5 g: 0.5 b: 0.5 a: 1
)
labelStyle = (
	^ 'font-family: sans-serif; font-size: 125%; color: green'
)
transactionsHeader = ( | lbl = label: 'Transactions'. |
	lbl visual at: #style put: labelStyle.
	^row: { lbl }.
)
computeDigits: ds = (
	| n = [ Float parse: ds ] on: Error do: [ :e | alert: 'Error: ', (e at: #error) at: #message. ^0 ]. |
   ^n * 100
)
currentBalance ^<Fragment> = (| lbl b bal n |
	bal:: Float parse: ((subject balance / 100) printString).
	n:: (JSNumber new: bal) toFixed: 2. n out.
	lbl:: label: 'Balance: $'.
    lbl visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
    b:: label: n.
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
			^row: { lbl. blank: 20. b }
)
) : (
)
public class BankTransactionEditPresenter onSubject: s = Presenter onSubject: s (
) (
) : (
isMyKind: p = (
	^ p isKindOfBankTransactionEditPresenter
)
isKindOfBankTransactionEditPresenter = (
	^true
)
definition = (
	^column: {
    	row: { dateEdit }.
    	row: { amtEdit }.
        row: {
        	saveButton.
            canxButton.
        }.
    }
)
dateEdit = (
)
amtEdit = (
)
saveButton = (
)
canxButton = (
)
)
public class BankTransactionEditSubject onModel: m <BankTransaction> parentSubject: s = Subject onModel: m (
	| parentSubject = s. |
) (
isMyKind: p = (
	^p isKindOfBankTransationEditSubject
)
isKindOfBankTransactionEditSubject = (
	^true
)
public save = (
	parentSubject save: model
)
public createPresenter = (
	^BankTransactionEditPresenter onSubject: self
)
public cancel = (
	presenter enterSubject: parentSubject
)
) : (
)
public transact: b <BankTransaction> = (
	^transactions add: b
)
public balance = (| rslt = 0.0. |
	(* 1 to: (transactions size) do: [ :i | rslt: rslt + ((transaction at: i) amount) ] .
		^rslt *) 
        ^transactions inject: 0.0 into: [ :s :t | s + t amount ].
	)
) : (
)
