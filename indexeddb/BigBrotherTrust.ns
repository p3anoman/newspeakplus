Newspeak3
'Root'
class BigBrotherTrust usingPlatform: platform = (
|
	private List = platform collections List.
    public JSObject = platform js global at: 'Object'.
    private Date = platform js global at: 'Date'.
    private Color = platform graphics Color.
    private Gradient = platform hopscotch Gradient.
	private Presenter = platform hopscotch core Presenter.

	private indexedDB = IndexedDB usingPlatform: platform.
    private IDBObject = indexedDB IDBObject.
    private IDBSubject = platform hopscotch core Subject mixinApply: indexedDB IDBSubject.

    public version = 1.
	public transactions = List new.
|
) (
public class BankTransaction amount: a onDate: d <Integer> formatted: s <String> = IDBObject (
	|
    amt = a.
    txDate = d.
    |
) (
class BankTransactionPresenter onSubject: s =  Presenter onSubject: s (
		) (
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankTransactionPresenter
		)
isKindOfBankTransactionPresenter = (
			^true
		)
public definition ^ <Fragment> = (
			^row: {  label: subject transactionDate. blank: 100 . txLabel. txAmount. }
		)
txLabel = ( | txt = subject amount < 0 ifTrue: [ 'Withdrawal:' ] ifFalse: [ 'Deposit:' ]. |
	^column: { label: txt. }
)
txAmount = (
	^column: { label: subject amount }
)
) : (
)
public class BankTransactionSubject onModel: t <BankTransaction> = Subject onModel: t (
		) (
public createPresenter = (
			^BankTransactionPresenter onSubject: self
		)
public transactionDate = (
			^model transactionDate
		)
public amount = (
			^model amount
		)
isKindOfBankTransactionSubject = (
	^true
)
isMyKind: s = (
	^s isKindOfBankTransactionSubject
)
) : (
)
public amount = (
			^amt
		)
public txSubject = (
	^BankTransactionSubject onModel: self
)
public transactionDate = (
			^txDate toDateString
		)
) : (
public keyPath = (
	^'uuid'
)
)
public class BankAccountSubject onModel: b <BigBrotherTrust> = IDBSubject onModel: b (
	| public transactions = List new. |
) (
withdrawals = (
		^txSubjets select: [ :t | t amount < 0 ]
	)
public createPresenter = (
		^BankAccountPresenter onSubject: self
	)
deposits = (
		^model transactions select: [ :t | t amount > 0 ]
	)
public balance = (
		^model balance
	)
public loadTx = (| tx nocors |
	nocors: (js global at: 'Object') new.
    nocors at: 'mode' put: 'no-cors'.
	tx:: (js global fetch: 'http://localhost:8077/transactions' with: nocors)
    		then: [ :r | r json then: [ :data | data ] ].
    ^tx
)
public deposit: amt = (
	transact: amt.
)
public withdraw: amt = (
	transact: (amt * -1).
)
public transactionSubjects = (
	^transactions
)
transact: amt = (| b s d |
		d:: Date now.
		s:: (Date new: d) toDateString.
		b:: BankTransaction amount: amt onDate: d formatted: s.
        add: b.
		model transact: b.
)
onUpgradeNeeded: event = (
    | o = JSObject new. |
    super onUpgradeNeeded: event.
	o  at: 'keyPath' put: 'uuid'.
   db createObjectStore: 'BankTransaction' with: o.
)
onSuccess: event = (
	| o = JSObject new. |
	super onSuccess: event.
    (* db getAll. *)
)
) : (
)
class BankAccountPresenter onSubject: s <BankAccountSubject> = Presenter onSubject: s (|
	stFlag = false.
|) (
isKindOfBankAccountPresenter = (
			^true
		)
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankAccountPresenter
		)
transactionList = (
			^column:  transactionPresenters.
		)
computeDigits: ds = (
| s ::= 0. |
	ds do: [:d | s:: (10 * s) + (d - 48)].
	^s
)
newDepositInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject deposit: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
newWithdrawalInput ^ <Fragment> = (
  | cm = codeMirror: ''. |
  cm acceptResponse: [:ed |
	updateGUI: [
		subject withdraw: (computeDigits: ed textBeingAccepted).
		ed text: ''.
		ed leaveEditState.
		]
	].
  ^cm
)
minorHeadingColor = (
	^Gradient from: Color gray to: Color white.
)
loadTx = (
	^subject loadTx
)
test = (
	^button: 'Tx' action: [ updateGUI: [ loadTx ]].
)
transactionsHeader = ( | l = label: 'Transactions'. |
	^row: { l }.
)
minorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.})
	color: minorHeadingColor.
)
majorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.}) color: majorHeadingColor.
)
majorHeadingColor = (
	^Gradient from: Color yellow to: Color gray.
)
logo = (| b = label: 'Big Brother Trust'. |
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 200%; text-align: center'.
	^row: { b }
)
header = ( | l = label: 'Your Money'. |
	l visual at: 'style' put: 'font-size: 200%'.
		^row: {  l. }
		)
public definition ^<Fragment> = (
	^column: {
    	logoBlock: logo.
		majorHeadingBlock: header.
		minorHeadingBlock: currentBalance.
		transactionsHeader.
		transactionList.
		row: { label: 'Deposit:' }.
        row: { newDepositInput. }.
		row: { label: 'Withdrawal:' }.
		row: { newWithdrawalInput. }.
        row: { test }
	}
)
logoBlock: body = (
	^(padded: body with: { 100. 75. 100. 75. }) color: logoColor.
)
logoColor = (
	^Gradient from: Color red to: Color yellow
)
currentBalance ^<Fragment> = (| l = label: 'Balance: $'. b = label: subject balance. |
	l visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
			^row: { l. blank: 20. b }
		)
transactionPresenters = (
	^subject transactions collect: [ :s | s presenter ]
)
) : (
)
public class IndexedDB usingPlatform: platform = (
	|
    (* Imports *)
    public List = platform collections List.
    public Map = platform collections Map.
    private ObjectMirror = platform mirrors ObjectMirror.
    private ClassMirror = platform mirrors ClassMirror.
	private JSObject = platform js global at: 'Object'.
    private crypto = platform js global at: 'crypto'.

    (* The browser's IndexedDB API object *)
    private indexedDB <Alien> = platform js global at: 'indexedDB'.
	|
) (
public class IDBStore forClass: c <IDBObject class> = (
	|
    storeClass <Class> = c.
    keyPath <String> = c keyPath.
    store <Alien>
    |
    createStore
) (
public save: o = (
	^IDBStoreRequest for: o on: self
)
get: aKey = (

)
createStore = (| o = JSObject new at: #keyPath put: keyPath; yourself. |
	'Creating objectStore' out.
	indexedDB createObjectStore: storeClass mixin name with: o.
)
) : (
)
public class IDBObject = (
	|
	uuid_slot
	|
) (
public store = (| cm = (ObjectMirror reflecting: self) getClass. |
	^stores at: cm ifAbsent: [
    	stores at: cm put: (IDBStore forClass: cm) ].
)
public asJSObject = (
	|
    m = ObjectMirror reflecting: self.
    cm = m getClass.
    o = JSObject new.
    |
	cm slots do: [ :slot | | n v | 
    	n: slot name. n out.
        v:: m getSlot: n.
        o at: n put: v reflectee
    ].
	^o
)
public uuid = (
	'uuid accessed' out.
	uuid_slot isNil ifTrue: [ uuid_slot:: crypto randomUUID ].
    ^uuid_slot
)
) : (
public keyPath = (
	^'uuid'
)
)
public class IDBSubject = (
(* 
	This class is to be used as a mixin whose many event handlers can be overriden by your application subject.
	Override onUpgradeNeeded to create the objectStores needed to store your model objects.
    Overrided onSuccess to load data?
    Currently, stores use the class name of the objects to be stored using IDBSubject's add: put: and delete: methods. Custom behavior would require overriding these.
*)
 |
 (* The connection to the application's database *)
 db <Alien>
 |
) (
public onBlocked: e = (
	'Blocked triggered' out.
)
modelClasses = (| m = (ObjectMirror reflecting: model) getClass mixin. |
	^m nestedClasses select: [ :c | c definingMixin superclass = IDBObject ]
)
public onTxComplete: event <Alien> = (
	'Transaction complete triggered' out.
)
public onTxError: e <Alien> = (
	'Transaction error triggered' out.
)
public onUpgradeNeeded: event <Alien> = (
    'upgradeneeded triggered' out.
    db::  (event at: #target) at: #result.
)
public onSuccess: event <Alien> = (
	'Open DB succeeded' out.
    db:: (event at: #target) at: #result.
)
public openDB = (
	|
    cm = (ObjectMirror reflecting: model) getClass. 
	request	= indexedDB open: cm mixin name version: model version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e | onSuccess: e. nil ].
    request addEventListener: 'error' with: [ :e | (e at: #error) out. nil ].
	'IDBSubject openDB called' out.
)
public delete: o = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx 
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].
    store:: tx objectStore: s.
    store delete: o asJSObject.
)
public put: o <IDBObject> = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx 
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].
    store:: tx objectStore: s.
    store put: o asJSObject.
)
public add: o = (
	| 
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx 
    store
    req
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    tx addEventListener: 'error' handler: [ :e | onTxError: e. nil ].
    store:: tx objectStore: s.
    req:: store add: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onSuccess: e. nil ]
)
) : (
)
) : (
)
public balance = (
		^transactions inject: 0 into: [ :s :t | s + t amount ].
	)
public deposit: b <BankTransaction> = (
	^transactions add: b
)
public withdraw: b <BankTransaction> = (
	    ^transactions add: t
	)
) : (
)
