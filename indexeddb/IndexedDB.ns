Newspeak3
'Root'
public class IndexedDB usingPlatform: platform = (
	|
		(*
        	Implements the browser API of the same name.
			IDBSubject is meant to be used as a mixin on your application subject. Some methods need to be overriden in the current incarnation.
			Model classes need to subclass IDBObject giving them the uuid slot and and the asJSObject method.
        	Implement the modelClasses method in your Subject/Top level class. An IDBObjectStore will be created for each class.
            Copyright 2024 John McKeon.
            MIT License. Use at your own risk.
    	*)
    public List = platform collections List.
    private ObjectMirror = platform mirrors ObjectMirror.
    private ClassMirror = platform mirrors ClassMirror.
	private JSObject = platform js global at: 'Object'.
    
    (* The browser's IndexedDB API object *)
    private indexedDB <Alien> = platform js global at: 'indexedDB'.
	|
) (
public class IDBObject uuid: id = (
	|
	public uuid = id.
	|
) (
public asJSObject = (
	|
    m = ObjectMirror reflecting: self.
    cm = m getClass.
    o = JSObject new.
    |
	cm slots do: [ :slot | | n v |
    	n: slot name.
        v:: m getSlot: n.
        o at: n put: v reflectee
    ].
	^o
)
) : (
public new: array = (
	^subclassResponsibility
)
)
public class IDBSubject = (
(*
	This class is to be used as a mixin whose many event handlers can be overriden by your application subject.
	Override onUpgradeNeeded to create the objectStores needed to store your model objects.
    Overrided onSuccess to load data?
    Currently, stores use the class name of the objects to be stored using IDBSubject's add: put: and delete: methods. Custom behavior would require overriding these.
*)
 |
 (* The connection to the application's database *)
 db <Alien>
 |
) (
modelClasses = (
	^subclassResponsibility
)
onBlocked: e = (
	'Blocked triggered' out.
)
public openDB = (
	openDB: model version.
)
delete: o onComplete: completeBlock onError: errorBlock = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock. (* [ :e | onTxComplete: e. nil ] *)
    tx addEventListener: 'error' handler: errorBlock. (* [ :e | onTxError: e. nil ]. *)
    store:: tx objectStore: s.
    store delete: o uuid.
)
add: o <IDBObject> = (
	add: o onComplete: [ :e | ] onError: [ :e | ]
)
delete: o <IDBObject> = (
	delete: o onComplete: [ :e | ] onError: [ :e | ]
)
put: o <IDBObject> = (
	put: o onComplete: [ :e | ] onError: [ :e | ]
)
onTxError: event <Alien> = (
	(* This is the default handler for error events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction error triggered' out.
)
onTxComplete: event <Alien> = (
	(* This is the default handler for completion events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction complete triggered' out.
)
get: aUUID forClass: c <IDBObject> onSuccess: successHandler = (
		| tx store req storeName = (ClassMirror reflecting: c) mixin name. |
    	tx:: db transaction: storeName for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: storeName.
    	req:: store get: aUUID.
    	req addEventListener: 'success' handler: successHandler.
)
getAllForClass: c <IDBObject> onSuccess: successHandler = (
		| tx store req storeName = (ClassMirror reflecting: c) mixin name. |
    	tx:: db transaction: storeName for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: storeName.
    	req:: store getAll.
    	req addEventListener: 'success' handler: successHandler.
)
onUpgradeNeeded: event <Alien> = (| o = JSObject new. |
	(* The default handler for the 'upgradeneeded' event generated on version change. *)
    (* This default 'Version 1' creates the required IDBObjectStores according to the classes returned by the modelClasses method as overridden by the application Subject *)
    (* This method plays a central role in n making database/model schema changes throughout the application lifecycle. *)
    db::  (event at: #target) at: #result.
	o  at: 'keyPath' put: 'uuid'.
   	modelClasses do: [ :m | | cm = ClassMirror reflecting: m. |
		db createObjectStore: cm mixin name with: o.
    ].
    'upgradeneeded triggered' out.
)
public openDB: version <Integer> = (
	|
    cm = (ObjectMirror reflecting: model) getClass.
	request	= indexedDB open: cm mixin name version: version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e | onOpen: e. nil ].
    request addEventListener: 'error' with: [ :e | Error signal: ((e at: #error) at: #message). nil ].
	'IDBSubject openDB called' out.
)
onOpen: event <Alien> = (
    (* The default 'success' handler for the open function. *)
    (* By default, we call getAll to retrieve all model objects for all classes returned in response the modelClasses message. *)
    (* This behavior can be overridden in the application's Subject *)
	'Open DB succeeded' out.
    db:: (event at: #target) at: #result.
    modelClasses do: [ :m |
		| tx store req cm = ClassMirror reflecting: m. |
    	tx:: db transaction: cm mixin name for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: cm mixin name.
    	req: store getAll.
    	req addEventListener: 'success' handler: [ :e | onGetAll: e. nil ].
    ].
)
onGetAll: event <Alien> ^ <List[IDBObject]> = (
	(* This is the default 'success' handler for the (IDBObjectStore getAll API. *)
    (* Returns an array of one model's instances. The model class used for instantiation is determined by the event source. *)
    (* The application WILL need to override this method calling 'super' to obtain the data returned. *)
	|
    tgt = event at: #target.
    r = tgt at: #result.
    src = (tgt at: 'source') at: 'name'.
    modelClass
    rslt = List new.
    |
    modelClass:: modelClasses detect: [ :cls | cls name = src ] ifNone: [ nil ].
    modelClass isNil ifTrue: [ Error signal: 'model class not found' ].
    1 to: (r at: #length) do: [ :i | | m o |
    	o:: r at: (i - 1).
        m:: modelClass new: (JSObject values: o).
        rslt add: m.
     ].
     ^rslt
)
add: o <IDBObject> onComplete: completeHandler onError: errorHandler = (
	|
    m = ObjectMirror reflecting: o.
	s = m getClass mixin name.
    tx
    store
    req
    |
    (* Create the UUID key for the model
    m setSlot: 'uuid' to: crypto randomUUID. *)

    (* Create the IDBTransaction *)
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeHandler.
    tx addEventListener: 'error' handler: errorHandler.

    (* Get the IDBObjectStore from the transaction *)
    store:: tx objectStore: s.

    (* Store the model object *)
    req:: store add: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onAdd: e. nil ]
)
onAdd: event = (
	'Success' out.
)
onPut: event = (
	'Put Success' out.
)
put: o <IDBObject> onComplete: completeBlock onError: errorBlock = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    req
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock.
    tx addEventListener: 'error' handler: errorBlock.
    store:: tx objectStore: s.
    req:: store put: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onPut: e. nil ]
)
) : (
)
) : (
)
