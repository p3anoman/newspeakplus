Newspeak3
'Root'
public class IndexedDB usingPlatform: p = (
	|
		(* :exemplar: IndexedDB usingPlatform: platform *)
        (*
        	Implements the browser API of the same name.
			Copyright 2024 John McKeon.
            MIT License. Use at your own risk.
    	*)
    private List <List> = p collections List.
    private ObjectMirror <ObjectMirror> = p mirrors ObjectMirror.
    private ClassMirror <ClassMirror> = p mirrors ClassMirror.

    private Subject <Subject> = p hopscotch Subject
    													mixinApply: p victoryFuel Serializer;
                                                        mixinApply: p victoryFuel Deserializer;
                                                        yourself.

	private JSObject <Alien[Object]> = p js global at: 'Object'.
    private crypto <Alien[Crypto]> = p js global at: 'crypto'.

    (* The browser's IndexedDB API object *)
    private indexedDB <Alien[IndexedDB]> = p js global at: 'indexedDB'.
	|
) (
public class IDBObject new = (
	| public uuid = crypto randomUUID. |
) (
public asJSObject ^<Alien[JSObject]> = (
	|
    m <ObjectMirror> = ObjectMirror reflecting: self.
    cm <ClassMirror> = m getClass.
    o <Alien> = JSObject new.
    |
	cm slots do: [ :slot | | n v |
    	n: slot name.
        v:: m getSlot: n.
        o at: n put: v reflectee
    ].
	^o
)
) : (
private class: k <Class> adoptInstance: object <VictoryFuel|IDBObject>= (
	(* :literalmessage: primitive: 134 *)
	halt.
)
public fromJSObject: o <Alien[JSObject]> usingClass: k <Class[IDBObject]> ^<IDBObject> = (
	|
	keys <Alien[Array[String]]> = JSObject keys: o.
	slotCount <Integer> = keys at: 'length'.
	values <Alien[Array[String|Number|Boolean|Object|Array]]> = JSObject values: o.
	tmpClass <TemporaryClass> = TemporaryClass withFormat: slotCount superclass: Object.
	instance <VictoryFuel> = tmpClass idbBasicNew.
	mirror <ObjectMirror>
	|
	class: k adoptInstance: instance.
	mirror:: ObjectMirror reflecting: instance.
	1 to: slotCount do: [ :i | mirror setSlot: (keys at: i-1) to: (values at: i-1). ].
	^instance
)
)
public class IDBSubject onModel: m <Object> modelClasses: i <Array[Class[IDBObject]]>
(* :exemplar_1: [
	IDBSubject onModel: List new modelClasses: {  } ] value
*)
= Subject onModel: m (
|
 (* The connection to the application's database *)
 public db <Alien[IDBDatabase]>
 public modelClasses = i.
 |
) (
add: o <IDBObject> = (
	add: o onComplete: [ :e | ] onError: [ :e | ]
)
delete: o <IDBObject> = (
	delete: o onComplete: [ :e | ] onError: [ :e | ]
)
put: o <IDBObject> = (
	put: o onComplete: [ :e | ] onError: [ :e | ]
)
onGet: e <Alien[Event]>^<IDBObject> = (
	|
    target <Alien> = event at: #target.
    src <String> = (target at: 'source') at: 'name'.
    o <Alien[JSObject]> = target at: #result.
    modelClass <Class[IDBObject]>
    |
    modelClass:: modelClasses detect: [ :cls | cls name = src ] ifNone: [ nil ].
    modelClass isNil ifTrue: [ Error signal: 'model class not found' ].
   	^ IDBObject fromJSObject: o usingClass: modelClass.
)
get: aUUID <UUID> forClass: c <Class[IDBObject]> = (
(* Not quite ready for primetime *)
		| tx store req storeName = (ClassMirror reflecting: c) mixin name. |
    	tx:: db transaction: storeName for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: storeName.
    	req:: store get: aUUID.
    	req addEventListener: 'success' handler: [ :e <Event> | onGet: e. nil ]
)
onAdd: event  <Alien[Event]> = (
	'Success' out.
)
onBlocked: e <Alien[Event]> = (
	'Blocked triggered' out.
)
onOpen: event <Alien[Event]> = (
    (* The default 'success' handler for the open function. *)
    (* By default, we call getAll to retrieve all model objects for all classes returned in response the modelClasses message. *)
    (* This behavior can be overridden in the application's Subject *)
	'Open DB succeeded' out.
    db:: (event at: #target) at: #result.
    modelClasses do: [ :m |
		|
        tx <Alien[IDBTransaction]>
        store <Alien[IDBObjectStore]>
        req <Alien[IDBOpenRequest]>
        cm <ClassMirror> = ClassMirror reflecting: m.
        |
    	tx:: db transaction: cm mixin name for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e <Alien[Event]> | onTxComplete: e. nil ].
    	store:: tx objectStore: cm mixin name.
    	req: store getAll.
    	req addEventListener: 'success' handler: [ :e <Alien[Event]> | onGetAll: e. nil ].
    ].
)
onTxComplete: event  <Alien[Event]> = (
	(* This is the default handler for completion events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction complete triggered' out.
)
onPut: event  <Alien[Event]> = (
	'Put Success' out.
)
onTxError: event  <Alien[Event]> = (
	(* This is the default handler for error events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction error triggered' out.
)
public openDB = (
	(* Use this version to let the subject's model provide the version number. In lieu of that, use the openDB: message *)
	openDB: model version.
)
public openDB: version <Integer> = (
	|
    cm <ClassMirror> = (ObjectMirror reflecting: model) getClass.
	request <Alien[IDBOpenRequest]>	= indexedDB open: cm mixin name version: version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e <Alien[Event]> | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e <Alien[Event]> | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e <Alien[Event]> | onOpen: e. nil ].
    request addEventListener: 'error' with: [ :e <Alien[Event]> | Error signal: ((e at: #error) at: #message). nil ].
	'IDBSubject openDB called' out.
)
put: o <IDBObject> onComplete: completeBlock onError: errorBlock = (
	|
    tx <Alien[IDBTransaction]>
    store <Alien[IDBObjectStore]>
    req <Alien[IDBRequest]>
	s <String> = (ObjectMirror reflecting: o) getClass mixin name.
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock.
    tx addEventListener: 'error' handler: errorBlock.
    store:: tx objectStore: s.
    req:: store put: o asJSObject.
    req addEventListener: 'success' handler: [ :e <Alien[Event]> | self onPut: e. nil ]
)
delete: o <IDBObject> onComplete: completeBlock <Closure> onError: errorBlock <Closure> = (
	|
    tx <Alien[IDBTransaction]>
    store <Alien[IDBObjectStore]>
	s <String> = (ObjectMirror reflecting: o) getClass mixin name.
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock.
    tx addEventListener: 'error' handler: errorBlock.
    store:: tx objectStore: s.
    store delete: o uuid.
)
onUpgradeNeeded: event <Alien[Event]> = (
	(* The default handler for the 'upgradeneeded' event generated on version change. *)
    (* This default 'Version 1' creates the required IDBObjectStores according to the classes returned by the modelClasses method as overridden by the application Subject *)
    (* This method plays a central role in making database/model schema changes throughout the application lifecycle. *)
	| o <Alien[JSObject]> = JSObject new. |
    db::  (event at: #target) at: #result.
	o  at: 'keyPath' put: 'uuid'.
   	modelClasses do: [ :m <Class[IDBObject]> |
    	| cm <ClassMirror> = ClassMirror reflecting: m. |
		db createObjectStore: cm mixin name with: o.
    ].
    'upgradeneeded triggered' out.
)
primordialObjects ^<Array[Class]> = (
	^{
		nil.
		false.
		true.

		SmallInteger.
		MediumInteger.
		LargeInteger.
		Float.
		ByteArray.
		String.
		Array.
		WeakArray.
		Ephemeron.
		Activation.
		Closure.
		Metaclass.

		Fraction.
		Method.
		Class.
		InstanceMixin.
		ClassMixin.

		Object.
		classOf: Object.
	}
)
public sharedObjects ^<Array[Class]> = (
	^primordialObjects addAll: modelClasses	
)
serialize: anObject <IDBObject>^<Alien[Object]> = (
	| jso <Alien[Object]> = JSObject new. |
	jso at: 'uuid' put: anObject uuid.
	jso at: 'psoup' put: (super serialize: anObject).
	^jso
)
deserialize: anObject <IDBObject> = (
	^super deserialize: anObject
)
add: o <IDBObject> onComplete: completeHandler <Closure> onError: errorHandler <Closure> = (
	|
    m <ObjectMirror> = ObjectMirror reflecting: o.
	s <String> = m getClass mixin name.
    tx <Alien[IDBTransaction]>
    store <Alien[IDBObjectStore]>
    req <Alien[IDBRequest]>
    serialized
    |
   (* Create the IDBTransaction *)
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeHandler.
    tx addEventListener: 'error' handler: errorHandler.

    (* Get the IDBObjectStore from the transaction *)
    store:: tx objectStore: s.

    (* Store the model object *)
	req:: store add: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onAdd: e. nil ]
)
onGetAll: event <Alien[Event]> ^ <List[IDBObject]> = (
	(* This is the default 'success' handler for the (IDBObjectStore getAll API. *)
    (* Returns a list of one model classes's instances. The model class used for instantiation is determined by the event source. *)
	|
    target <Alien> = event at: #target.
    r <Array> = target at: #result.
    src <String> = (target at: 'source') at: 'name'.
    modelClass <Class[IDBObject]>
    rslt <List> = List new.
    |
    modelClass:: modelClasses detect: [ :cls | cls name = src ] ifNone: [ nil ].
    modelClass isNil ifTrue: [ Error signal: 'model class not found' ].
    1 to: (r at: #length) do: [ :i | | m o |
    	o:: r at: (i - 1).
        m:: IDBObject fromJSObject: o usingClass: modelClass.
        rslt add: m.
     ].
     ^rslt
)
) : (
)
class TemporaryClass withFormat: fmt <Integer> superclass: s <Class> = (|
	superclass <Class> = s.
	methods <List> = {}.
	enclosingObject <Object> = nil.
	mixin <Mixin> = nil.
	classIndex <Integer> (* < ? > *)
	format <Integer> = fmt.
	public name  <String> = 'IDBVictoryFuelObject'.
	subclasses <List> (* < ? > *)
|) (
public idbBasicNew ^<Bytes> = (
	(* :literalmessage: primitive: 34 *)
	halt.
)
) : (
)
) : (
)
