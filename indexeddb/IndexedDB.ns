Newspeak3
'Root'
public class IndexedDB usingPlatform: p = (
	|
		(*
        	Implements the browser API of the same name.
			IDBSubject is meant to be used as a mixin on your application subject. Some methods need to be overriden in the current incarnation.
			Model classes need to subclass IDBObject giving them the uuid slot and and the asJSObject method.
        	Implement the modelClasses method in your Subject/Top level class. An IDBObjectStore will be created for each class.
            Copyright 2024 John McKeon.
            MIT License. Use at your own risk.
    	*)
    public List = p collections List.
    private ObjectMirror = p mirrors ObjectMirror.
    private ClassMirror = p mirrors ClassMirror.
    private Subject = p hopscotch core Subject.

	private JSObject = p js global at: 'Object'.
    private crypto = p js global at: 'crypto'.

    (* The browser's IndexedDB API object *)
    private indexedDB <Alien> = p js global at: 'indexedDB'.
	|
) (
public class IDBObject new = (
	| public uuid = crypto randomUUID. |
) (
public asJSObject ^<Alien> = (
	|
    m <ObjectMirror> = ObjectMirror reflecting: self.
    cm <ClassMirror> = m getClass.
    o <Alien> = JSObject new.
    |
	cm slots do: [ :slot | | n v |
    	n: slot name.
        v:: m getSlot: n.
        o at: n put: v reflectee
    ].
	^o
)
) : (
private class: k <Class> adoptInstance: object <VictoryFuel|IDBObject>= (
	(* :literalmessage: primitive: 134 *)
	halt.
)
public fromJSObject: o <Alien> forClass: k <Class> ^<IDBObject> = (
	|
	keys = JSObject keys: o.
	slotCount = keys at: 'length'.
	values = JSObject values: o.
	tmpClass = TemporaryClass withFormat: slotCount.
	instance = tmpClass victoryFuel.
	mirror <ObjectMirror>
	|
	class: k adoptInstance: instance.
	mirror:: ObjectMirror reflecting: instance.
	1 to: slotCount do: [ :i | mirror setSlot: (keys at: i-1) to: (values at: i-1). ].
	^instance
)
)
public class IDBSubject onModel: m = Subject onModel: m (
(*
	This class is to be used to as the subclass of your main application subject.
	Override onUpgradeNeeded to create the objectStores needed to store your model objects.
    Overrided onSuccess to load data?
    Stores are automatically created for the classes returned by the application subject's modelClasses method.
*)
 |
 (* The connection to the application's database *)
 db <Alien>
 |
) (
modelClasses = (
	^subclassResponsibility
)
onBlocked: e = (
	'Blocked triggered' out.
)
public openDB = (
	openDB: model version.
)
delete: o onComplete: completeBlock onError: errorBlock = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock. (* [ :e | onTxComplete: e. nil ] *)
    tx addEventListener: 'error' handler: errorBlock. (* [ :e | onTxError: e. nil ]. *)
    store:: tx objectStore: s.
    store delete: o uuid.
)
add: o <IDBObject> = (
	add: o onComplete: [ :e | ] onError: [ :e | ]
)
delete: o <IDBObject> = (
	delete: o onComplete: [ :e | ] onError: [ :e | ]
)
put: o <IDBObject> = (
	put: o onComplete: [ :e | ] onError: [ :e | ]
)
onTxError: event <Alien> = (
	(* This is the default handler for error events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction error triggered' out.
)
onTxComplete: event <Alien> = (
	(* This is the default handler for completion events generated by transactions used in the onOpenSuccess handler. *)
	(* Application subjects can override this handler. *)
	'Transaction complete triggered' out.
)
onUpgradeNeeded: event <Alien> = (| o = JSObject new. |
	(* The default handler for the 'upgradeneeded' event generated on version change. *)
    (* This default 'Version 1' creates the required IDBObjectStores according to the classes returned by the modelClasses method as overridden by the application Subject *)
    (* This method plays a central role in n making database/model schema changes throughout the application lifecycle. *)
    db::  (event at: #target) at: #result.
	o  at: 'keyPath' put: 'uuid'.
   	modelClasses do: [ :m | | cm = ClassMirror reflecting: m. |
		db createObjectStore: cm mixin name with: o.
    ].
    'upgradeneeded triggered' out.
)
public openDB: version <Integer> = (
	|
    cm = (ObjectMirror reflecting: model) getClass.
	request	= indexedDB open: cm mixin name version: version.
    |
    request addEventListener: 'upgradeneeded' with: [ :e | onUpgradeNeeded: e. nil ].
    request addEventListener: 'blocked' with: [ :e | onBlocked: e. nil ].
    request addEventListener: 'success' with: [ :e | onOpen: e. nil ].
    request addEventListener: 'error' with: [ :e | Error signal: ((e at: #error) at: #message). nil ].
	'IDBSubject openDB called' out.
)
onOpen: event <Alien> = (
    (* The default 'success' handler for the open function. *)
    (* By default, we call getAll to retrieve all model objects for all classes returned in response the modelClasses message. *)
    (* This behavior can be overridden in the application's Subject *)
	'Open DB succeeded' out.
    db:: (event at: #target) at: #result.
    modelClasses do: [ :m |
		| tx store req cm = ClassMirror reflecting: m. |
    	tx:: db transaction: cm mixin name for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: cm mixin name.
    	req: store getAll.
    	req addEventListener: 'success' handler: [ :e | onGetAll: e. nil ].
    ].
)
add: o <IDBObject> onComplete: completeHandler onError: errorHandler = (
	|
    m = ObjectMirror reflecting: o.
	s = m getClass mixin name.
    tx
    store
    req
    |
    (* Create the UUID key for the model
    m setSlot: 'uuid' to: crypto randomUUID. *)

    (* Create the IDBTransaction *)
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeHandler.
    tx addEventListener: 'error' handler: errorHandler.

    (* Get the IDBObjectStore from the transaction *)
    store:: tx objectStore: s.

    (* Store the model object *)
    req:: store add: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onAdd: e. nil ]
)
onAdd: event = (
	'Success' out.
)
onPut: event = (
	'Put Success' out.
)
put: o <IDBObject> onComplete: completeBlock onError: errorBlock = (
	|
	s = (ObjectMirror reflecting: o) getClass mixin name.
    tx
    store
    req
    |
	tx:: db transaction: s for: 'readwrite'.
    tx addEventListener: 'complete' handler: completeBlock.
    tx addEventListener: 'error' handler: errorBlock.
    store:: tx objectStore: s.
    req:: store put: o asJSObject.
    req addEventListener: 'success' handler: [ :e | self onPut: e. nil ]
)
getAllForClass: c <IDBObject> onSuccess: successHandler = (
(* Not quite ready for primetime *)
		| tx store req storeName = (ClassMirror reflecting: c) mixin name. |
    	tx:: db transaction: storeName for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: storeName.
    	req:: store getAll.
    	req addEventListener: 'success' handler: successHandler.
)
get: aUUID forClass: c <IDBObject> onSuccess: successHandler = (
(* Not quite ready for primetime *)
		| tx store req storeName = (ClassMirror reflecting: c) mixin name. |
    	tx:: db transaction: storeName for: 'readonly'.
   		tx addEventListener: 'complete' handler: [ :e | onTxComplete: e. nil ].
    	store:: tx objectStore: storeName.
    	req:: store get: aUUID.
    	req addEventListener: 'success' handler: successHandler.
)
onGetAll: event <Alien> ^ <List[IDBObject]> = (
	(* This is the default 'success' handler for the (IDBObjectStore getAll API. *)
    (* Returns a list of one model classes's instances. The model class used for instantiation is determined by the event source. *)
	|
    target = event at: #target.
    r <Array> = target at: #result.
    src = (target at: 'source') at: 'name'.
    modelClass
    rslt = List new.
    |
    modelClass:: modelClasses detect: [ :cls | cls name = src ] ifNone: [ nil ].
    modelClass isNil ifTrue: [ Error signal: 'model class not found' ].
    1 to: (r at: #length) do: [ :i | | m o |
    	o:: r at: (i - 1).
        m:: IDBObject fromJSObject: o forClass: modelClass.
        rslt add: m.
     ].
     ^rslt
)
) : (
)
class TemporaryClass withFormat: fmt = (|
	superclass = Object.
	methods = {}.
	enclosingObject = nil.
	mixin = nil.
	classIndex
	format = fmt.
	public name = 'IDBVictoryFuelObject'.
	subclasses
|) (
public victoryFuel = (
	(* :literalmessage: primitive: 34 *)
	halt.
)
) : (
)
) : (
)
