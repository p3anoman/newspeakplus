Newspeak3
'Root'
class BigBrotherTrust usingPlatform: platform indexedDB: idb = (
|
	private List = platform collections List.
    private Color = platform graphics Color.
    private Gradient = platform hopscotch Gradient.
	private Presenter = platform hopscotch core Presenter.
    private Subject = platform hopscotch core Subject.

	public JSObject = platform js global at: 'Object'.
    private Date = platform js global at: 'Date'.
    private JSNumber = platform js global at: 'Number'.
    private Math = platform js global at: 'Math'.
    private crypto = platform js global at: 'crypto'.

	private indexedDB = idb.
    private IDBObject = indexedDB IDBObject.
    private IDBSubject = platform hopscotch core Subject mixinApply: indexedDB IDBSubject.

    public version = 1.
	public transactions = List new.
|
) (
public class BankTransaction id: uuid 
													amount: a <String>
                                                    onDate: d <Integer> 
                                                    memo: m <String>
                                                    reconciled: r <Boolean> = IDBObject uuid: uuid (
	|
    public amount = a.
    public txDate = d.
    public memo ::= m.
    public reconciled ::= r.
    |
) (
public transactionDate = (
			^(Date new: txDate) toDateString
		)
) : (
public new: array = (
	^self id: (array at: 0) amount: (array at: 1) onDate: (array at: 2) memo: (array at: 3) reconciled: (array at: 4)
)
public amount: a = (
	^id: crypto randomUUID amount: a
)
public id: id amount: a = (
	^id: id amount: a onDate: Date now memo: '' reconciled: false.
)
)
class BankTransactionPresenter onSubject: s =  Presenter onSubject: s (
		) (
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankTransactionPresenter
		)
isKindOfBankTransactionPresenter = (
			^true
		)
dateColumn= (| lbl = label: subject transactionDate. |
	lbl visual at: 'style' put: style.
	^column: { lbl }
)
typeColumn = ( | lbl = label: subject transactionType. |
	lbl visual at: 'style' put: style.
	^column: { lbl. }
)
style = (
	^'font-family: sans-serif; font-size: 110%; color: slateGray'
)
deleteButton = (
	^button: 'Delete' action: [ updateGUI: [ subject delete ] ]
)
amountColumn = (| lbl = label: ((JSNumber new: (subject amount / 100)) toFixed: 2). |
	lbl visual at: 'style' put: style, 'text-align: right'.
	^column: { lbl }
)
memoColumn = ( | lbl = label: subject memo. |
	lbl visual at: 'style' put: style.
	^column: { lbl }
)
definition ^ <Fragment> = (
	^transactionBlock: transactionRow
)
transactionRow = (
	^row: {  
			dateColumn.
            blank: 50.
            typeColumn.
            blank: 50.
            memoColumn.
            blank: 50.
            amountColumn.
            blank: 100.
            reconciledColumn.
            blank: 100.
            editButton.
            deleteButton.
	}
)
transactionBlock: row = (
	^(padded: row with: { 25. 5. 25. 5. }) color: (Color r: 0.99 g: 0.99 b: 0.99 a: 1).
)
editButton = (
	^button: 'Edit' action: [
    	| m = prompt: 'Edit memo' input: subject memo. |
        updateGUI: [ subject edit: m ].
    ]
)
reconciledColumn = (
	^column: { checkbox: 'Reconciled' value: subject reconciled action: [ :ck | updateGUI: [ subject toggleReconciled ] ] }
)
) : (
)
public class BankTransactionSubject onModel: t <BankTransaction> parent: s <IDBSubject> = Subject onModel: t (
	|
    parent = s.
    |
) (
public createPresenter = (
			^BankTransactionPresenter onSubject: self
		)
isKindOfBankTransactionSubject = (
	^true
)
isMyKind: s = (
	^s isKindOfBankTransactionSubject
)
public amount = (
			^model amount
		)
public transactionDate = (
 ^model transactionDate
)
public transactionType = (
	^amount < 0 ifTrue: [ 'Withdrawal:' ] ifFalse: [ 'Deposit:' ]
)
public delete = (
	parent delete: model.
)
public edit = (
	parent edit: model
)
public memo = (
	^model memo
)
public reconciled = (
	^model reconciled
)
public edit: theMemo <String> = (
	model memo: theMemo.
    parent edit: model.
)
public toggleReconciled = (
	(* Do not allow to "unreconcile" *)
	model reconciled ifFalse: [ model reconciled: true. parent edit: model ]
)
) : (
)
public class BankAccountSubject onModel: b <BigBrotherTrust> = IDBSubject onModel: b (
) (
withdrawals = (
		^txSubjets select: [ :t | t amount < 0 ]
	)
public createPresenter = (
		^BankAccountPresenter onSubject: self
	)
deposits = (
		^model transactions select: [ :t | t amount > 0 ]
	)
public balance = (
		^model balance
	)
modelClasses = (
	^{ BankTransaction. }
)
public transactionSubjects = (
	^transactions collect: [ :t | BankTransactionSubject onModel: t parent: self ]
)
onGetAll: event <Alien> = (
	| txs = super onGetAll: event. |
    txs do: [ :tx | transactions add: tx ].
    presenter refresh.
)
public withdraw: amt = ( 
	transact:: amt * -1
)
add: b <BankTransaction> = (
        add: b
        	onComplete: [ :e | 
            	'Tx complete' out.
            	model transact: b.
                presenter refresh.
                nil ]
            onError: [ :e | presenter alert: ((e at: 'error') at: 'message'). nil ]
)
public test1000 = (
	1 to: 1000 do: [ :i | | b a |
    	b:: BankTransaction amount: (Math random: 100) * 100 * 100.
    	super add: b ]
)
transact: amt withMemo: m = (| b s d |
		d:: Date now.
		b:: BankTransaction id: crypto randomUUID amount: amt onDate: d memo: m reconciled: false.
        add: b
)
transact: amt = (
		transact: amt withMemo: ''
)
public deposit: amt withMemo: m = (
	transact: amt withMemo: m.
)
public deposit: amt = (
	deposit: amt withMemo: ''.
)
public edit: transaction = (
	put: transaction
    	onComplete: [ :e | nil. ]
        onError: [ :e | Error signal: ((e at: 'error') at: 'message'). nil. ]
)
public delete: o = (
	delete: o 
    	onComplete: [ :e | transactions remove: o.  nil ] 
        onError: [ :e |  Error signal: 'Failed to delete transaction: ', ((e at: #error) at: 'message'). nil ]
)
) : (
)
class BankAccountPresenter onSubject: s <BankAccountSubject> = Presenter onSubject: s (|
	stFlag = false.
|) (
isKindOfBankAccountPresenter = (
			^true
		)
isMyKind: p <Presenter> ^ <Boolean> = (
		  ^p isKindOfBankAccountPresenter
		)
transactionList = (
			^column:  transactionPresenters.
		)
minorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.})
	color: minorHeadingColor.
)
majorHeadingBlock: body = (
	^(padded: body with: {50. 25. 25. 25.}) color: majorHeadingColor.
)
logo = (| b = label: 'Big Brother Trust'. |
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 200%; text-align: center'.
	^row: { b }
)
header = ( | l = label: 'Your Money'. |
	l visual at: 'style' put: 'font-size: 200%'.
		^row: {  l. }
		)
logoBlock: body = (
	^(padded: body with: { 100. 75. 100. 75. }) color: logoColor.
)
logoColor = (
	^Color white
)
public refresh = (
	updateGUI: [ ].
)
labelTransactions = ( | lbl = label: 'Transactions'. |
	lbl visual at: #style put: labelStyle.
	^ lbl
)
minorHeadingColor = (
	^Color r: 0.8 g: 0.8 b: 0.8 a: 1.
)
transactionPresenters = (
	^subject transactionSubjects collect: [ :s | s presenter ]
)
majorHeadingColor = (
	^Color r: 0.5 g: 0.5 b: 0.5 a: 1
)
labelStyle = (
	^ 'font-family: sans-serif; font-size: 125%; color: green'
)
transactionsHeader = ( | lbl = label: 'Transactions'. |
	lbl visual at: #style put: labelStyle.
	^row: { lbl }.
)
currentBalance ^<Fragment> = (| lbl b bal n |
	bal:: Float parse: ((subject balance / 100) printString).
	n:: (JSNumber new: bal) toFixed: 2. n out.
	lbl:: label: 'Balance: $'.
    lbl visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
    b:: label: n.
	b visual at: 'style' put: 'font-family: sans-serif; font-size: 150%; text-align: center'.
			^row: { lbl. blank: 20. b }
)
labelWithdrawal = (| lbl =  label: 'New Withdrawal:'. |
	lbl visual at: #style put: labelStyle.
    ^lbl
)
labelDeposit = (| lbl = label: 'New Deposit:'. |
	lbl visual at: #style put: labelStyle.
    ^lbl
)
computeDigits: ds = (
	| n |
    '' = ds ifTrue: [ ^0 ].
    n:: [ Float parse: ds ] on: Error do: [ n: 0 ].
   ^n * 100
)
public definition ^<Fragment> = ( | r style |
	^column: {
    	logoBlock: logo.
		majorHeadingBlock: header.
		minorHeadingBlock: currentBalance.
        inputRow.
		row: { labelTransactions }.
		transactionList.
        row: {label: 'For entertainment purposes only. No warranty experssed or implied.' }.
   }
)
newWithdrawalInput ^ <Fragment> = (
	^button: 'Record a withdrawal' action: [ | a m v |
    	a:: prompt: 'Enter amount' input: ''. 
        m:: prompt: 'Enter a memo' input: ''.
        v:: computeDigits: a.
        0 = v
        	ifFalse: [  updateGUI: [subject withdraw: v withMemo: m ]]
            ifTrue: [ alert: 'Invalid amount. Try again' ]
	].
)
newDepositInput ^ <Fragment> = (
	^button: 'Record a deposit' action: [ | a m v |
    	a:: prompt: 'Enter amount' input: ''. 
        m:: prompt: 'Enter a memo' input: ''.
        v:: computeDigits: a.
        0 = v
        	ifFalse: [  updateGUI: [subject deposit: v withMemo: m ]]
            ifTrue: [ alert: 'Invalid amount. Try again' ]
	].
)
inputRow = (| r style |
	r:: row: {
    	padded: newDepositInput with: { 50. 10. 25. 10 }.
        blank: 25. 
        padded: newWithdrawalInput with: { 25. 10. 25. 10. }.
        (* button: 'Test' action: [ subject test1000. updateGUI: [ ]] *)
    }.
	style:: r visual at: 'style'.
	style setProperty: 'width' value: '100%'.
    ^r
)
) : (
)
public transact: b <BankTransaction> = (
	^transactions add: b
)
public balance = (| rslt = 0.0. |
	(* 1 to: (transactions size) do: [ :i | rslt: rslt + ((transaction at: i) amount) ] .
		^rslt *) 
        ^transactions inject: 0.0 into: [ :s :t | s + t amount ].
	)
) : (
)
